# pdcp_security_project/main.py
import random
import logging
import os # For os.urandom()
from src.pdcp_entity import PDCPTransmitter, PDCPReceiver
from src.channel_simulator import ImpairedChannel
from src.crypto_stub import generate_key
from src import cipher_stub # For cipher key generation
import config

# Configure logging
logging.basicConfig(level=getattr(logging, config.LOG_LEVEL.upper(), logging.INFO),
                    format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s')
logger = logging.getLogger(__name__)

def run_simulation_basic(num_sdus, sdu_payload_size,
                         tx_integrity_enabled, rx_integrity_enabled,
                         tx_ciphering_enabled, rx_ciphering_enabled,
                         integrity_key_tx, integrity_key_rx,
                         cipher_key_tx, cipher_key_rx,
                         channel_params, specific_tamper_sdu_id=None):
    """Runs a single simulation instance."""
    logger.info("================== Starting Simulation ==================")
    logger.info(f"Parameters: Num SDUs: {num_sdus}, Integrity Tx/Rx: {tx_integrity_enabled}/{rx_integrity_enabled}, "
                f"Ciphering Tx/Rx: {tx_ciphering_enabled}/{rx_ciphering_enabled}")
    logger.info(f"Channel Params: {channel_params}")
    if specific_tamper_sdu_id is not None:
        logger.info(f"Specifically tampering SDU ID: {specific_tamper_sdu_id}")

    # Initialize PDCP entities
    pdcp_tx = PDCPTransmitter(bearer_id=config.BEARER_ID_DRB1,
                              direction=config.DIRECTION_UPLINK,
                              integrity_key=integrity_key_tx,
                              cipher_key=cipher_key_tx,
                              integrity_enabled=tx_integrity_enabled,
                              ciphering_enabled=tx_ciphering_enabled,
                              sn_length_bits=config.SN_LENGTH_BITS)

    pdcp_rx = PDCPReceiver(bearer_id=config.BEARER_ID_DRB1,
                            direction=config.DIRECTION_UPLINK,
                            integrity_key=integrity_key_rx,
                            cipher_key=cipher_key_rx,
                            integrity_enabled=rx_integrity_enabled,
                            ciphering_enabled=rx_ciphering_enabled,
                            sn_length_bits=config.SN_LENGTH_BITS)

    channel = ImpairedChannel(**channel_params)

    transmitted_pdus_log = []
    received_at_rx_log = []
    sdu_payloads_sent = {}

    for sdu_id in range(num_sdus):
        # SDU PAYLOAD GENERATION
        base_string = f"SDU_{sdu_id}_Data_"
        remaining_length_for_random_part = sdu_payload_size - len(base_string.encode('utf-8'))
        
        random_hex_data = ""
        if remaining_length_for_random_part > 0:
            num_bytes_from_os_urandom = remaining_length_for_random_part // 2
            if num_bytes_from_os_urandom > 0:
                random_hex_data = os.urandom(num_bytes_from_os_urandom).hex()
        
        payload_content_str = base_string + random_hex_data
        sdu_payload = payload_content_str.encode('utf-8')

        if len(sdu_payload) > sdu_payload_size:
            sdu_payload = sdu_payload[:sdu_payload_size]
        elif len(sdu_payload) < sdu_payload_size:
            sdu_payload += b'\x00' * (sdu_payload_size - len(sdu_payload))
        # END OF SDU PAYLOAD GENERATION

        sdu_payloads_sent[sdu_id] = sdu_payload

        pdu = pdcp_tx.send_sdu(sdu_id, sdu_payload)
        transmitted_pdus_log.append(pdu)

        pdus_for_channel = [pdu]
        arrived_pdus = channel.transmit(pdus_for_channel)
        
        for arrived_pdu in arrived_pdus:
            received_at_rx_log.append(arrived_pdu)
            pdcp_rx.receive_pdu(arrived_pdu)

    remaining_pdus = channel.flush_reorder_buffer()
    for pdu in remaining_pdus:
        received_at_rx_log.append(pdu)
        pdcp_rx.receive_pdu(pdu)

    delivered_sdus_info = pdcp_rx.get_delivered_sdus()
    rx_stats = pdcp_rx.get_stats()

    logger.info("================== Simulation Ended ==================")
    logger.info(f"Total SDUs generated by TX: {num_sdus}")
    logger.info(f"Total PDUs prepared by TX: {len(transmitted_pdus_log)}")
    logger.info(f"Total PDUs arrived at RX input (after channel): {len(received_at_rx_log)}")
    logger.info(f"RX Successfully Delivered SDUs: {rx_stats['successful_deliveries']}")
    logger.info(f"RX Discarded - Integrity Failures: {rx_stats['discarded_integrity_failures']}")
    logger.info(f"RX Discarded - Duplicates: {rx_stats['discarded_duplicates']}")
    logger.info(f"RX Discarded - Old Packets: {rx_stats['discarded_old_packets']}") 
    logger.info(f"RX Packets still in reordering buffer: {rx_stats['buffered_packets']}")

    for delivered in delivered_sdus_info:
        original_payload = sdu_payloads_sent.get(delivered['sdu_id'])
        if original_payload != delivered['payload']:
            logger.error(f"Payload Mismatch for SDU ID {delivered['sdu_id']}! "
                         f"Original len: {len(original_payload if original_payload else b'')}, Delivered len: {len(delivered['payload'] if delivered['payload'] else b'')}")

    return {
        "tx_pdus_count": len(transmitted_pdus_log),
        "rx_input_pdus_count": len(received_at_rx_log),
        "delivered_sdus_count": rx_stats['successful_deliveries'],
        "integrity_failures": rx_stats['discarded_integrity_failures'],
        "duplicate_discards": rx_stats['discarded_duplicates'],
        "delivered_sdu_ids": sorted([item['sdu_id'] for item in delivered_sdus_info]),
        "all_tx_pdus_details": transmitted_pdus_log,
        "all_rx_input_pdus_details": received_at_rx_log,
    }

if __name__ == "__main__":
    sim_integrity_key = generate_key(config.INTEGRITY_KEY_LENGTH_BYTES)
    sim_cipher_key = cipher_stub.generate_cipher_key(config.CIPHER_KEY_LENGTH_BYTES)

    # Default channel settings from config
    channel_settings = {
        "loss_rate": config.LOSS_RATE,
        "duplication_rate": config.DUPLICATION_RATE,
        "reordering_rate": config.REORDERING_RATE,
        "max_reorder_delay": config.MAX_REORDER_DELAY,
        "corruption_rate": config.CORRUPTION_RATE,
        "tampering_rate": config.TAMPERING_RATE
    }

    # Scenario 1: Default run
    logger.info("\n--- Running Default Scenario ---")
    results = run_simulation_basic(
        num_sdus=config.NUM_SDUS,
        sdu_payload_size=config.SDU_PAYLOAD_SIZE_BYTES,
        tx_integrity_enabled=config.INTEGRITY_ENABLED_FOR_DRB,
        rx_integrity_enabled=config.INTEGRITY_ENABLED_FOR_DRB,
        tx_ciphering_enabled=config.CIPHERING_ENABLED_FOR_DRB,
        rx_ciphering_enabled=config.CIPHERING_ENABLED_FOR_DRB,
        integrity_key_tx=sim_integrity_key,
        integrity_key_rx=sim_integrity_key,
        cipher_key_tx=sim_cipher_key,
        cipher_key_rx=sim_cipher_key,
        channel_params=channel_settings
    )
    logger.info("Default Scenario completed.")

    # Scenario 2: Key Mismatch
    logger.info("\n--- Running Key Mismatch Scenario ---")
    mismatched_integrity_key_rx = generate_key(config.INTEGRITY_KEY_LENGTH_BYTES)
    clean_channel_params = { # Explicitly define all for clarity
        "loss_rate": 0.0, "duplication_rate": 0.0, "reordering_rate": 0.0,
        "max_reorder_delay": 0, "corruption_rate": 0.0, "tampering_rate": 0.0
    }
    results_key_mismatch = run_simulation_basic(
        num_sdus=10,
        sdu_payload_size=config.SDU_PAYLOAD_SIZE_BYTES,
        tx_integrity_enabled=True,
        rx_integrity_enabled=True,
        tx_ciphering_enabled=True,
        rx_ciphering_enabled=True,
        integrity_key_tx=sim_integrity_key,
        integrity_key_rx=mismatched_integrity_key_rx, # Mismatched key
        cipher_key_tx=sim_cipher_key,
        cipher_key_rx=sim_cipher_key,
        channel_params=clean_channel_params
    )
    if results_key_mismatch["rx_input_pdus_count"] > 0 :
        assert results_key_mismatch["integrity_failures"] == results_key_mismatch["rx_input_pdus_count"]
        assert results_key_mismatch["delivered_sdus_count"] == 0
    logger.info("Key Mismatch Scenario completed as expected.")

    # Scenario 3: Integrity Disabled with Tampering
    logger.info("\n--- Running Integrity Disabled with Tampering Scenario ---")
    tampering_channel_params = {
        "loss_rate": 0.0, "duplication_rate": 0.0, "reordering_rate": 0.0,
        "max_reorder_delay": 0, "corruption_rate": 0.0, # Isolate tampering
        "tampering_rate": 0.1 # 10% tampering
    }
    results_integrity_disabled = run_simulation_basic(
        num_sdus=20,
        sdu_payload_size=config.SDU_PAYLOAD_SIZE_BYTES,
        tx_integrity_enabled=False, # Integrity Disabled
        rx_integrity_enabled=False, # Integrity Disabled
        tx_ciphering_enabled=True,  # Ciphering still ON
        rx_ciphering_enabled=True,
        integrity_key_tx=sim_integrity_key, # Key provided but not used for integrity
        integrity_key_rx=sim_integrity_key,
        cipher_key_tx=sim_cipher_key,
        cipher_key_rx=sim_cipher_key,
        channel_params=tampering_channel_params
    )
    assert results_integrity_disabled["integrity_failures"] == 0
    # Delivered count should be num_sdus if no other impairments (like loss) are active
    assert results_integrity_disabled["delivered_sdus_count"] == 20 
    logger.info(f"Integrity Disabled Scenario: Delivered {results_integrity_disabled['delivered_sdus_count']} SDUs (tampered ones will have corrupt data).")
    logger.info("Integrity Disabled Scenario completed as expected.")